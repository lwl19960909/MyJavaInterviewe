# **网络：** 

## 	1、OSI七层模型与TCP/IP 五层模型

OSI的七层模型自底向上：

* 物理层

* 数据链路层

  主要是物理寻址，将原始比特流转变为逻辑传输路线，主要协议，ARP。

* 网络层 

  网络层主要通过IP寻址来建立两个IP节点之间的连接。主要协议IP协议。

* 传输层

  传输层主要负责建立主机端到端之间的链接，为上层提供透明的数据传输服务（接收上层的数据，进行分割并交给网络层）。常见的协议有TCP,UDP。

* 会话层

  为不同主机上的用户之间建立和管理会话

* 表示层

  信息的语义语法以及他们的关联，比如加密解密，压缩解压缩等。

* 应用层

  常见的应用层协议包括HTTP，HTTPS，FTP等

TCP/IP五层模型将OSI七层模型的上三层合并为了应用层：

即物理层，数据链路层，网络层，传输层，应用层。

## 	2、常见应用层协议和运输层、网络层协议，以及硬件如路由器之类在哪一层 

应用层：HTTP，HTTPS，FTP等

运输层：TCP，UDP

网络层：IP，ICMP

硬件属于那一层主要看它所了解的信息：

1. 啥都不知到的是物理层，比如绝迹的hub
2. 知道的多一点，只知道MAC不知道IP的，是数据链路层，常见的网卡，网桥，交换机
3. 再知道的多一点，直到IP不知道端口的，比如路由器，是网络层
4. 在知道的多一点，IP+端口就是传输层以上的了，一般的就一台计算机。

## 	3、TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些 

TCP和UDP最主要的区别是：TCP是面向链接，可靠的字节流服务。UDP是面向数据报的不可靠的服务。

(另外报文头长得不一样（协议不一样当然长得不一样），UDP就是，源目长验各16，剩下的就是数据。TCP的话就是源目16，序列确认32，校验16，其他杂七杂八的，注意这里的源目都是端口号。)

UDP的特点：无连接，不可靠，面向数据报。最主要的：TFTP,DNS

TCP：有连接，可靠，面向数据流。最主要的：HTTP,HTTPS,SSH,FTP

## 	4、TCP可靠传输的保证，拥塞控制目和过程 

可靠性传输：

1. 确认应答机制+序列号

   TCP对每一个字节数据都进行了编号，即为序列号，每次发送ACK确认信息时都会带有对应的序列号，表示期待下次发送的数据的起始位置，比如收到1~N，发送的ACK携带的序列号就是N+1.

2. 超时重传+序列号

   当由于网络原因经过一个超时重传的时间还没有收到确认消息，就会从上一个收到的确认序列号开始重发，防止出现重复数据。

3. 拥塞控制

   慢开始，拥塞控制，快重传，快恢复

![拥塞控制](D:\MyData\luwl8\Desktop\spring学习\拥塞控制.png)

假设数据单向传输，并且接收方有足够的缓冲区。

发送方会维持一个拥塞窗口（CWnd,congestion window）的状态变量，它是动态变化的主要取决于网络状况。

变化的原则是：当网络状况良好时就增大，出现网络拥塞时就减小。判断发生网络拥塞的依据是：规定时间内没有收到应该收到的确认报文（即发生超时重传）。

发送方维持一个SWnd = CWnd，表示再未收到确认的情况下所能放送的最多的分段数。

发送方维持一个慢开始阈值（ssthresh）：

CWnd < ssthresh 执行慢开始，即CWnd每次扩大2倍。

CWnd > ssthresh 执行拥塞避免，即CWnd每次加1。

CWnd = ssthresh 均可。

慢开始是指一开始窗口比较小，拥塞避免的意思是，线性增加这样比较不容易出现拥塞。

实际的环境下，有可能会出现个别报文丢失而实际上网络状况良好的情况，如果此时被判断为网络拥塞重新开始执行慢开始，会降低传输效率，因此提出了快重传和快恢复。

快重传是指：

1. 接收方收到消息后立即发送确认。
2. 发送方连续收到三个确认之后就将该报文段立即重传（不等到超时）。
3. 个别丢失的报文，发送方不会出现超时重传，不会误认为出现了拥塞。

发送方一旦受到三个重复的确认，就知道丢失了个别报文，于是执行快恢复算法：

1. 发送方将ssthresh和CWnd设为当前值的一半并开始执行拥塞避免。

## 	5、TCP粘包现象原因和解决方法 

粘包中的包指的是应用层的数据包，在TCP协议的协议头中没有像UDP的那种报文长度字段，但是有一个序列号字段，接收方将接受到的TCP报文按照序列号排序放在缓冲区，但是应用层看到的只是一串连续的字节数据，并不知道哪部分到哪部分是完整的应用层数据包。

解决方法：

1. 定长包就固定长度读取。
2. 变长的包可以在报文头里约定一个总长度字段
3. 包之间有明确的分隔符
4. TLV格式的数据传输。TLV<Tag,length,value>

## 	6、TCP三次握手过程以及每次握手后的状态改变，为什么三次？为什么两次不行？如果你的答案是防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源，但这个答案被否定了，你还能给出什么答案？ 

客户端SYN_SENT   -----SYN J ------>>>>>>  服务端SYN_RCVD

客户端ESTABLISHED<<<<<<-------SYN K,ACK J+1 ----服务端SYN_RCVD

客户端ESTABLISHED -------ACK K+1-------->>>>服务端ESTABLISHED

三次不是两次的原因很简单：

因为TCP是一个双向的协议，双方都必须维持一个序列号，以此来标识发送出数据包中哪些是被收到的，三次握手的过程是双方互相告知起始序列号的过程。

## 	7、TCP四次挥手过程以及状态改变，为什么四次？CLOSE-WAIT和TIME-WAIT存在的意义？如何查看TIME-WAIT状态的链接数量？为什么会TIME-WAIT过多？解决方法是怎样的？ 

客户端FIN_WAIT_1 ------------FIN M ------->>>>服务器CLOSE_WAIT

客户端FIN_WAIT_2<<<-------ACK M+1 -------服务器CLOSE_WAIT

客户端TIME_WAIT <<<-------FIN N -----------服务器LAST_ACK

客户端TIME_WAIT---------------ACK N+1 ------->>>>>服务器CLOSED

CLOSE_WAIT存在的意义是为了解决断开连接时，客户端的数据已经送完毕，而服务端的数据还没有发送完毕的情况。

TIME_WAIT的状态是为了解决以下问题。假如没有TIME_WAIT，由于网络问题如果ACK N+1没有按时到达服务器，由于此时客户端已关闭，客户端可重新向服务器发送建立连接请求，前后两次连接的端口号可能是一样的，若那个迟到的报文此时到达服务器，由于TCP是根据端口对来判断是不是一个链接的数据，那么就会这位这个数据是新的，造成混淆，所以在TIME_WAIT后还要等待两个MSL（MSL报文存活最长时间，即ACK N+1，和重发的FIN N）保证以前的旧数据都已经在网络中消失。

查看TIME_WAIT主要使用netstat命令

产生的原因一般是由于设置中TCP协议中为了安全关闭，主动断开链接的一方会在进入CLOSED之前等待两个MSL，而一个MSL根据采用的标准不同所设置的时间不同，可能是30秒~2分钟，所以假如大量的客户端和服务器进行短连接访问，服务器主动断开链接，那么在4分钟之内可能会积压几十万的TIME_WAIT链接占用大量的资源。

解决方法可以是设置相关的系统参数：

net.ipv4.tcp_syncookies=1  表示SYN队列溢出时启用cookie处理
net.ipv4.tcp_tw_reuse = 1  表示允许将处于TIME_WAIT的socket重新用于建立链接
net.ipv4.tcp_tw_recycle = 1 表示开启TCP中TIME_WAIT socket的快速回收
net.ipv4.tcp_fin_timeout = 30 修改系统默认的TIME_OUT时间。

```
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_fin_timeout = 30
```

## 	8、TCP、UDP、IP、以太网报文格式以及重要字段，报文从一端到另一端传递的过程。

 **TCP：**

16位的：源端口，目的端口，校验和，窗口大小（协商发送数据的大小）

32位的：序列号，确认号

六个控制位：**ACK,FIN,SYN,RST**,URG,PSH

数据

**UDP**：

源目长（报文长度）验16

数据

**IP**：

4位：版本，头长度

8位：TTL（表示程村周期，每经过一个路由减一，防止路由环路的问题），协议标识

13位：片偏移（IP报文要进行分片）

16位：总长度，校验和

32位：源地址，目的地址

数据

**以太网帧:**

前导码：7字节，主要用于双方发送接收速率的同步

SFD：1字节，帧开始符

目的MAC地址/源MAC地址：6字节

长度，类型：2字节

数据

校验和：4字节。

一个完整的以太网帧如下：

以太网首部+IP首部+TCP首部+HTTP首部+请求数据+以太网尾部

![](D:\MyData\luwl8\Desktop\spring学习\以太网报文.png)

## 	9、浏览器输入URL并回车的过程以及相关协议，DNS查询过程。 

大体上的流程分为以下几个步骤：

1. URL解析

   URL解析主要是判断你输入的URL是否是一个合法的URL，并且根据你输入的URL进行自动补全。此处的协议是http、HTTPS协议。

2. DNS查询 

   域名查询使用的是UDP协议

3. TCP链接

   TCP/IP协议

4. 服务器处理请求并返回响应

5. 浏览器接受响应并渲染页面。



DNS解析过程如下：

域名查询的流程如下：

浏览器缓存--》操作系统缓存--》路由器缓存--》ISP DNS缓存--》根域名服务器--》顶级域名服务器--》主域名服务器--》本地域名服务器

1. 当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址，如果没有就去检查hosts，如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存。（此处是客户端的DNS缓存）

2. 当在用户客服端查找不到域名对应IP地址，则将进入ISP（互联网服务提供商） DNS缓存中进行查询。
3. 当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；
4. 顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；
5. 主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；
6. 本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。

## 	10、HTTP1.0、1.1、2.0之间的区别 

HTTP2相对与1.1最主要的区别在于：

1. HTTP2使用的是二进制格式而不是文本格式

2. HTTP2是完全多路复用

   HTTP1.x要处理多个并行的请求需要建立多个链接，而建立链接本身需要一定的开销。HTTP2基于多路复用，一个链接可以处理多个请求。

3. HTTP2使用了header压缩，加快了传输效率

4. HTTP2，服务端可以主动将响应推送给客户端。

   即除了原始请求外，服务器还可以向客户端推送额外的资源。

HTTP1.0和1.1之间最大的区别是：

1. 1.0规定客户端和浏览器之间使用短连接，即每次请求都建立连接，完成后断开连接，由于TCP建立和断开链接过程较为复杂，开销很大，所以HTTP1.1将链接默认是长链接（设置请求头的Connection为keep--alive）。
2. 1.1添加了host字段以解决多个虚拟主机对应一个IP的问题。
3. 1.1添加了100 CONTINUE的状态码，客户端可以先发送一个只有请求头的请求，如果返回100就继续完整的请求，如果服务器因为权限拒绝请求返回401，就无需发送完整请求了，节约了带宽。

## 	11、HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？

1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前网易官网是http，而网易邮箱是 https 。)

2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。

3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

建立过程简略如下：

① **客户端的浏览器向服务器发送请求**，并传送客户端 SSL 协议的[版本号](https://baike.baidu.com/item/版本号)，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。

② **服务器向客户端传送** SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。

③ 客户端利用服务器传过来的信息**验证服务器的合法性**。

④ 用户端**随机产生一个用于通讯的 "对称密码"**，然后用服务器的**公钥**（服务器的公钥从步骤②中的服务器的证书中获得）对其**加密**，然后将加密后的“预主密码”传给服务器。

⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。

⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性

⑦ **服务器和客户端用相同的对称加密密钥**，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要**完成数据通讯的完整性**，防止数据通讯中的任何变化。

⑧ **客户端向服务器端发出信息**，**指明**后面的数据通讯将**使用**的步骤 **⑦ 中的主密码为对称密钥**，同时**通知**服务器客户端的**握手过程结束**。

⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。

⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。

ps:加密算法自行了解。。。

## 	12、HTTP请求有哪些，多说点。Post和get区别。 

get 从服务器获取数据，可缓存，有长度限制

head 方法同get，不过没有响应体

post 将数据发送到服务器

put 将数据发送到服务器，和post不同的是put相当于是SQL的update，而post则类似于insert。

delete 删除指定资源

options　返回服务器预定义URL的HTTP策略

还有connect、trace记不住。。。

post和get的区别：

两方面：表象和本质

表象：

1. get只支持URL编码，post支持多重编码
2. get会被浏览器主动缓存，post不会
3. get比post更不安全因为所有的参数都在URL上
4. get在URL中传送的参数是有长度限制的
5. get参数会被完整保存在浏览器记录里，post不会 

本质（作为装逼用）：

post和get都是借由下层的TCP实现的，所以在本质上post和get没有什么区别。但是浏览器装载和拆卸URL都需要一定的开销而且数据太大是一种负担，所以浏览器限制URL的长度是2K，服务器限制64K。其他规范是HTTP对两种请求所做的规范化要求。

另外GET请求只产生一个TCP数据包，POST产生两个数据包。网络好的时候一次两次差别不大，网络不好的时候两次可靠性更高。

get时，会一次性发送header和data服务器返回200 OK

post时会先发送header服务器返回100 CONTINUE 在发送data返回200 OK。（也有例外Firefox就只发送一次）

## 	13、HTTP常见响应状态码，从1xx到5xx都要说。 

ps(。。。我只记得住这么多)

100 Continue 继续提出请求。

200 Ok  请求响应都成功，服务器通信正常。
302 Move temporarily 设置重定向页面跳转的动作执行。

400 Bad Request，请求报文存在语法错误

401 Unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息

403 Forbidden 访问被服务器拒绝。

404 Not Found  请求失败，请求所希望得到的资源未被在服务器上发现。一般是用户输错了url导致.
405 Method Not Allowed  请求行中指定的请求方法不存在。例如,发送post请求,服务器没有doPost方法,就会报这个错误.
500 Internal Server Error  服务器发生了错误。一般服务器代码错误 

## 	14、重定向和转发区别 

转发和重定向最根本的区别在于页面跳转的发起人是谁。

转发是有服务器发起的页面跳转，一般的过程是：

浏览器发送请求，服务器接受请求，并调用内部的方法完成请求的处理和转发，然后将结果返回给客户端。

重定向是客户端行为，浏览器发送请求，服务器接受并返回302，浏览器再次向新的地址发送请求，服务器接受并处理返回数据。

## 	15、cookie和session区别。

 由于http是一个无状态的协议，面对交互式网站的出现多带来的需要跟踪记录用户状态的问题，需要借助其他手段来解决。

cookie的出现是为了弥补http无状态的问题，由于cookie保存在客户端，容易被窃取伪造，就出现了session的概念，将重要的信息存放在服务器，并由服务器生成一个sessionid作为身份的验证，但是大量的session信息增加了服务器的负担。

所以token的出现了，通过某种加密算法，对用户信息进行加密生成一个token，服务器只保存密钥，客户端每次请求只需将token和部分不重要的用户信息发送到服务器，服务器根据自己的密钥对token进行解密并验证就可以识别用户身份。

1. cookie是保存在本地的，session是保存在服务器的。
2. cookie的存活依赖于设置的存活时间，即使关闭浏览器，在未达到失效时间时依然存活。session在关闭浏览器时就结束了。
3. cookie是个实际存在的东西的，存在于报文头里，而session是一个逻辑概念，需要通过其他的方式实现。

ps:token也是一种验证用户身份的方式

# **操作系统：** 

## 1、进程和线程的区别 

1. 进程是操作系统分配资源的基本单位，线程是调度和执行的基本单位。
2. 进程有独立的数据空间和代码，同一个进程的线程之间共享代码和数据空间。
3. 进程可以独立执行，但是线程要依附于进程才能执行。
4. 一个进程崩溃后在保护模式下不会对其他的进程造成影响，而线程崩溃会造成整个进程崩溃。
5. 一个进程包含多个线程，一个线程对应一个进程。

## 2、协程呢？ 

协程既不是进程也不是线程，协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。

多个协程在线程内顺序执行。

协程是一种特殊的函数，和进程线程不是一个纬度的。

进程和线程的切换依赖于操作系统，而协程的切换是用户自己控制的，没有进入内核态，所以比较快。

## 3、进程间通信方式IPC 

管道，消息队列，信号量，共享文件。

**管道**

管道的基本思想是在内核中申请一块固定大小的缓冲区，进程拥有写入和读取的权利。

特点是：面向字节流，自带同步互斥，单向通信。

**消息队列**

消息队列是消息的链表，有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。**

**信号量**

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。**它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源**。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

**共享文件**

共享内存就是映射一段能被其他进程所访问的内存，**这段共享内存由一个进程创建，但多个进程都可以访问**。**共享内存是最快的 IPC 方式，**（因为无需切换到内核态去读取数据）它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

## 4、用户态和核心态 

用户态主要运行用户程序。

核心态运行操作系统程序，操作硬件等。

处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

用户态到内核态的切换一般有三种：系统调用，外部设备中断（如IO），异常。

## 5、操作系统分配的进程空间是怎样的？线程能共享哪些？ 

ps:这个问题描述的不是很清楚，我不是很理解是想问内存分配方式还是分配后内存空间的组成部分，前者的话参考6，后者的话参考JVM内存体系。

JAVA中线程共享的就是堆和元空间。

## 6、操作系统内存管理方式，分页分段以及段页式的优缺点 

内存管理方式主要分为连续分配和离散分配

ps(内部碎片，分配给进程的内存，有些部分没有用得上。

外部碎片：空闲空间太小难以被利用。)

**连续分配：单一分区分配，固定分区分配，动态分区分配**

**单一分区分配**，**内存被分为系统区和用户区，内存中只能有一个用户程序。**

优点：简单无碎片

缺点：效率低。

**固定分区分配**，将用户空间分成**若干个固定大小的分区，每个分区只装一个用户程序。需要建立分区说明表，**包括大小，起始地址，使用与否。

优点：简单**没有外部碎片**

缺点：**产生内部碎片**，当程序过大会使用覆盖技术降低效率。

**动态分区分配，根据进程的大小动态建立分区**

优点，没有内部碎片

缺点，有外部碎片（可通过紧凑解决）

**离散分配：页式管理、段式管理和段页式管理。**

**页式管理**的基本原理是将各进程的虚拟空间划分为若干个长度相等的页。把**内存空间按页的大小划分为片或者页面，然后把页式虚拟地址与内存地址建立一一对应的页表**，并用相应的硬件地址转换机构来解决离散地址变换问题。页式管理采用请求调页和预调页技术来实现内外存存储器的统一管理。

优点：**没有外碎片**，每个内碎片不超过页的大小。

缺点：程序全部装入内存，**要求有相应的硬件支持**，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。

**段式管理**的基本思想是**把程序按内容或过程函数关系分成段**，每段有自己的名字。一个用户作业或者进程所包含的段对应一个二维线性虚拟空间，也就是一个二维虚拟存储器。段式管理程序**以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换为实际内存物理地址**。

优点：可以**分别编写和编译**，可以针对不同类型的段采取不同的保护，可以**按段为单位来进行共享**，包括通过动态链接进行代码共享。

缺点：**会产生碎片**。

段页式管理，系统必须**为每个作业或者进程建立一张段表**以管理内存分配与释放、缺段处理等。另外由于**一个段又被划分为若干个页**，每个段必须建立一张页表以把段中的虚页变换为内存中的实际页面。显然与页式管理时相同，页表也要有相应的实现缺页中断处理和页面保护等功能的表项。

段页式管理是段式管理和页式管理相结合而成，**具有两者的优点**。

由于**管理软件的增加，复杂性和开销也增加**。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。

## 7、页面置换算法有哪些，FIFO为什么不好？如何改进?LRU思想，手写LRU 

* OPT最佳置换算法：

  移除永远不再使用的页面，如果没有就移除最长时间内不再被使用的页面。（理想算法）

* FIFO先进先出置换算法

  淘汰最早进入内存的页面。因为在内存中停留最久的应该是是使用最为频繁的，但是由于FIFO，在达到一定时间后这些页面不得不被置换出去。FIFO存在的另一个异常就是增加可用的存储块，缺页中断的次数反而增加了。

* LRU最近最久未使用

  其基本思想是：如果以最近的过去作为不久将来的近似，那么就可以把过去最长一段时间里不曾被使用的页面置换掉。它的实质是，当需要置换一页时，选择在之前一段时间里最久没有使用过的页面予以置换。

* CLOCK时钟置换算法

  其基本思想是将最近没有使用过的页面替换掉。

  基本的clock算法是给每个页面维持一个状态变量u，u=1表示最近使用过，0表示最近没使用过。时钟指针会遍历所有一面，直到遇到第一个u=0的页面停下并将其替换出去，在期间遇到的所有u=1的页面全部置0。

  为了进行优化，由于如果页面发生修改，写回磁盘时也会有一定的开销，如果优先驱逐没有修改过的页面，则会降低IO。

  改进clock就是在原来基础上再增加一个状态变量m表示是否被修改过。

  * u=0, m=0没被使用也没被修改最先被删除
  * u=1,m=0用过但没修改，第二优先删除
  * u=0,m=1没用过但是修改了，第三优先删除
  * u=1,m=1用过修改过，最后被删除

  算法过程如下：在指针遍历过程中修改遇到的所有的u=1为u=0，优先寻找00，实在没有再找01.

## 8、死锁条件，解决方式。 

死锁的四个必要条件：

1. 互斥条件
2. 请求和保持条件
3. 循环等待
4. 不可剥夺

一般的话解决死锁问题的方式分为两种：事前预防和事后解决。

事前预防就是破坏死锁的四个必要条件，不过一般不考虑破坏互斥条件。

* 破坏请求和保持条件：即在申请新的资源之前，释放目前使用不到的资源。或者系统要么一次性分配所有资源，要么都不分配。
* 破坏循环等待条件：即按相同的顺序请求资源
* 破坏不可剥夺条件：如果一个进程请求资源被拒绝，那么它需要释放所占有的资源。

一般的方法加锁顺序和加锁限时，银行家算法。

事后解决就是检测死锁并解决。比如：挂起死锁进程并剥夺资源，撤销进程并释放资源。

## **Java基础** 

## 1、面向对象特性介绍、与C++区别 

面向对象主要有四种特性：唯一，抽象，继承，多态。

唯一是指每个对象都有唯一的标识，可以通过这个标识找到对象。

抽象是指将具有已知数据结构和操作的对象抽象成类。

继承是类和类之间的关系，是一种“是”的关系。**继承性是子类自动共享父类数据结构和方法的机制**，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。在java中类的继承只支持单继承。

多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。



java面向对象的三种特性是：封装，继承，多态

封装就是通过修改访问权限（private），使外部程序无法直接访问到类的内部信息，而是通过类提供的方法进行访问。

继承同面向对象（extends）。

多态具体体现在父类的引用可以指向子类，子类通过重写父类方法实现不同的效果。



java和c++的区别：

* 语言层面
  * java中不存在指针
  * java是纯面向对象的语言，所有程序都必须封装在类里，而c++为了做到向c兼容，保留了一部分面向过程的特性
  * c++程序是由编译器直接编译成机器语言，而java程序则是有编译器编译成class文件再交由虚拟机执行。

* 类和继承层面
  * c++支持多继承，而java支持单继承多实现。
  * c++具备“类”概念的有类，结构体，联合体这些，而java只有类
* 操作层面
  * java没有运算符重载
  * java取消了goto
* 内存管理方面
  * 由于JVM的存在，java具有自动的内存管理，但是c++并不存在需要手动的申请释放内存。

## 2、多态实现原理 

多态的实现是由方法调用的动态绑定实现的。

```java
class Party{ 
    void happyHour(){ 
        Person girl = new Girl(); 
        girl.speak(); 
    } 
 }
```

对于上述代码，不妨假设girl.speak()编译后的代码为：invokevirtual #12。

invokevirtual #12表示执行Party的常量池的第12行。

![](D:\MyData\luwl8\Desktop\spring学习\方法动态绑定.png)

这个过程，首先JVM回去查看Party的常量池中索引为12的条目，该条目应该是speak方法的符号引用，根据这个符号引用进一步查找常量池去找到这个方法是Person的speak方法，查看Person的方法表，得出speak方法在偏移量为15的地方，这就是speak方法的直接引用。

解析出该方法的直接引用后，JVM开始执行真正调用：根据参数this从堆中获取到具体的对象（即girl所引用的堆中的Girl对象），然后根据这个对象对应的方法表，调用某个偏移量所指向的方法。（Girl中speak的方法的实现）。

## 3、抽象类和接口区别，以及各自的使用场景 

1. 抽象类是类，在Java中类只支持单继承，但是接口可以支持多实现。
2. 抽象类里支持方法的声明和实现，但是接口只支持方法的声明（所以接口中不能包含静态方法，因为静态方法必须要实现）。
3. 接口的成员变量只能是public static final，而抽象类不必。

抽象类的主要目的是为了提取出子类的相同特征和相同操作，其关注的焦点在于事物的本身，而接口则主要聚焦于事物的某一个操作。举个例子：人是一个抽象类，这个抽象类不但具备人的各种特征，也包括吃饭说话等行为，而说话是一个接口，它只具备说话这个动作。

## 4、泛型以及泛型擦除。List\<A>类型的list,可以加入无继承关系的B类型对象吗？如何加入？ 

​	java泛型是在JDK1.5中引入的一个新的特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，这个参数类型可以用在，类，接口，方法的创建中，分别成为泛型类/接口/方法。

泛型带来的主要的好处是：

1. **类型安全**，通过使用泛型对变量的类型进行限制，编译器可以在编译时就对变量的类型进行验证，这样就能更早的补货类型错误，而不是在运行中才能捕获。
2. **消除强制类型转换**
3. **提高运行效率**，在没有泛型时，简单类作为Object传递时会有装箱和拆箱操作，存在一定的开销，在集合类的时候尤其明显，但是使用泛型就可以不用进行装箱和开箱，提高效率。

泛型擦除：

Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，**即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure）**，将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。
泛型的类型擦除原则是：

1. 消除类型参数声明，即**删除<>及其包围的部分**。
2. **根据类型参数的上下界推断并替换所有的类型参数为原生态类型**：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。
3. 为了保证类型安全，必要时插入强制类型转换代码。
4. **自动产生“桥接方法”**以保证擦除类型后的代码仍然具有泛型的“多态性”。

桥接方法：

```java
public interface Info<T>{
    T info(T var);
} 

class Test implements Info<Integer>{

    @Override
    public Integer info(Integer var) {
        return var;
    }
}
```

当执行类型擦除以后上面就变成了：

```java
public interface Info<Object>{
    Object info(Object var);
} 

class Test implements Info{

    @Override
    public Integer info(Integer var) {
        return var;
    }
}
```

显然Test的info方法不是所要重写的的方法，为了解决这个问题编译器在编译Test时默认添加了一个方法：

```java
public volatile Object info(Object obj)
{   
    return info((Integer)obj);
}
```

用此方法来连接。

## 5、Java异常体系 

java异常体系的目的是为了提高代码的健壮性，实现业务代码和错误处理的分离。

异常分为两类：error和exception均继承自Throwable。

error：一般是指程序无法处理的错误，表示程序运行时出现的重大错误。

exception：可以分为检查性异常（非运行时异常）和非检查性异常（运行时异常）。对于检查性异常，要求程序必须捕获处理，否则将会编译不通过，非检查性异常，不要求，（但可以捕获处理）编译时可以通过。

java对于异常的处理，可以使用try/catch捕获并处理异常，亦可以使用throw抛给上级处理，如果最终都没能找到处理异常的入口，那么异常就会交由JVM进行处理，**JVM会打印异常的栈轨迹**，并且终止程序。

在捕获异常并处理时要注意**小先大后**，如果先捕获大异常（层级较高的父类），那么后面的异常处理将不再执行。

## 6、反射原理以及使用场景 

Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。

使用场景比如IOC。

ps手写一个简单的（基于注解的）IOC：

前置条件：定义两个注解，MyBean，和MyAutowired

1.获取给定路径下所有的.class文件的文件名，然后使用ClassForName反射获取所有的类。

2.遍历所有的类，筛选出标注有@MyBean的类通过（.getAnnotation(MyBean.class)），使用HashMap存储注解为bean的类

3.HashMap中key为首字母小写的类名，val为newInstance出来的实例

4.遍历所有bean，检测bean是否包含有@MyAutowired的字段，如果有就设置该字段引用到对应的bean。

## 7、ThreadLocal原理，如何使用

Threadlocal的本质是通过将共享变量复制一份到自己的工作区域变成自己的局部变量的方式解决线程安全。

使用方式：

```java
//以user为例
ThreadLocal<User> UserManager = new ThreadLocal<User>();

User user = new User();
//设置User实例
UserManager.set(user);

//获取Threadlocal变量
UserManager.get();
```

使用场景：spring中单例的bean被多线程使用。

Thread会维持一个ThreadLocalMap(类似于hashmap，不同的是，1.对key的引用是弱引用，2.解决冲突是采用开放地址法，hashmap采用的是拉链法)，其中key就是Threadlocal变量本身，value是变量的副本的值。

由于threadloclmap的key是弱引用，当Threadlocal被置为null时或者触发GC弱引用被清除导致的这个entry的key为null，由于ThreadlocalMap由Thread维护，所以在线程结束前并不会被回收，但是由于key为null，这个entry的value无法被访问到，所以造成了内存泄漏。

解决办法可以调用一次ThreadlocalMap的get或者set去清除可以为null的entry。

## 8、内存泄漏的场景 

## 9、static关键字和final关键字使用情况，一个类不能被继承，除了final关键字之外，还有什么方法（从构造函数考虑）？



## 10、序列化和反序列化。反序列化失败的场景。 

## 11、ArrayList和LinkedList的区别和底层实现？如何实现线程安全？ 

## 12、List遍历时如何删除元素？fail—fast是什么？fail—safe是什么？ 

## 13、详细介绍HashMap。角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N+JDK1.7与JDK1.8的区别。 

## 14、HashMap如何实现线程安全？ConcurrentHashMap的底层实现？JDK1.7与JDK1.8的区别 

## 15、正则表达式会写吗？ 

## 16、设计模式了解吗？ 

## 17、linux指令知道哪些？ 

# **JVM相关** 

## 1、JVM运行时内存划分？PC+虚拟机栈+本地方法栈+堆+方法区+JDK1.7与1.8区别 

## 2、堆内存分配策略 

## 3、Full GC触发条件 

## 4、如何判断对象是否存活？回收对象的两次标记过程。 

## 5、垃圾回收算法以及垃圾回收器介绍，尤其是G1和CMS的优缺点 

## 6、创建一个对象的步骤 

## 7、详细介绍类加载过程 

## 8、双亲委派机制，使用这个机制的好处？破坏双亲委派机制的场景？如何破坏？ 

## 9、了解下tomcat的类加载机制 

## 10、JVM性能调优，常用命令，以及工具 

# **多线程并发** 

## 1、进程线程区别，线程安全和非线程安全区别 

进程和线程的区别见操作系统。

线程安全和线程不安全的区别在于程序并发执行和串行执行的结果是否一致，一致就是线程安全，不一致就是线程不安全

## 2、线程状态，start,run,wait,notify,yiled,sleep,join等方法的作用以及区别 
线程的状态包括：
* 新建：新创建的一个线程对象
* 可运行：线程对象创建后，其他线程调用了该对象的start方法，该状态的线程位于可运行的线程池中，等待被线程调度选中，获取CPU权限开始执行。
* 运行：可运行状态的线程获得了CPU时间片，执行程序代码
* 阻塞：阻塞状态是指线程因为某种原因放弃CPU使用权，也让出了CPU的时间片，暂时停止运行。直到线程进入可运行状态，才有机会再次获得CPU权限转到运行态的机会。

start方法是启动线程，使线程的状态更改为可运行状态
run方法是线程所要执行的业务逻辑、
wait方法是阻塞当前线程，但是不释放CPU资源
notify方法唤醒某一个线程，使其从阻塞状态变为可运行态
sleep方法，阻塞当前线程，并且释放CPU资源
join方法把指定线程加入到当前线程中


## 3、wait,notify阻塞唤醒确切过程？在哪阻塞，在哪唤醒？为什么要出现在同步代码块中，为什么要处于while循环中？ 

## 4、线程中断，守护线程 

## 5、Java乐观锁机制，CAS思想？缺点？是否原子性？如何保证？ 

## 6、synchronized使用方法？底层实现？ 

## 7、ReenTrantLock使用方法？底层实现？和synchronized区别？ 

## 8、公平锁和非公平锁区别？为什么公平锁效率低？ 

## 9、锁优化。自旋锁、自适应自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、重量级锁解释 

## 10、Java内存模型 

## 11、volatile作用？底层实现？禁止重排序的场景？单例模式中volatile的作用？ 

## 12、AQS思想，以及基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍 

## 13、线程池构造函数7大参数，线程处理任务过程，线程拒绝策略 

## 14、Execuors类实现的几种线程池类型，阿里为啥不让用？ 

## 15、线程池大小如何设置？ 

## 16、手写简单的线程池，体现线程复用 

## 17、手写消费者生产者模式 

## 18、手写阻塞队列 

## 19、手写多线程交替打印ABC 

## **MySQL** 

## 1、事务4大特性，一致性具体指什么？这4个特性mysql如何保证实现的？ 

## 2、事务隔离级别，4个隔离级别分别有什么并发问题？ 

## 3、Mysql默认隔离级别？如何保证并发安全？ 

## 4、RR和RC如何实现的？RR使用场景？对比volatile可见性，为什么RR的事务要设计成不能读另一个事务已经提交的数据？

## 5、隔离级别的单位是数据表还是数据行？如串行化级别，两个事务访问不同的数据行，能并发？ 

## 6、存储引擎Innodb和Myisam的区别以及使用场景 

## 7、 介绍Inodb锁机制，行锁，表锁，意向锁 

## 8、介绍MVCC. 

## 9、哈希索引是如何实现的？ 

## 10、B树索引为什么使用B+树，相对于B树有什么优点？为什么不能红黑树？要提到磁盘预读 

## 11、聚簇索引和非聚簇索引区别 

## 12、回表查询和覆盖索引 

## 13、如何创建索引？ 

## 14、如何使用索引避免全表扫描？ 

## 15、Explain语句各字段的意义 

## 16、最左前缀！！联合索引B+树是如何建立的？是如何查询的？当where子句中出现>时，联合索引命中是如何的? 如 where a > 10 and b = “111”时，联合索引如何创建？mysql优化器会针对得做出优化吗？ 

## 17、MySQL中一条SQL语句的执行过程 

## 18、数据库几大范式 

## 19、数据库基本查询关键字使用，如left join on,where,beteen and,group by,having,limit,聚合函数等。 

## 20、left join,right join,inner join,outer join的含义及区别 

## 21、mysql主从复制过程，binlog记录格式，复制的异步半同步同步模式区别 

## 22、主从复制或读写分离等数据不一致性问题以及如何解决 

## 23、银行的话，可以会考mysql数据类型，如余额要用decimal 

# **Redis问题：** 

## 1、为什么使用Redis 

## 2、分布式缓存和本地缓存有啥区别？让你自己设计本地缓存怎么设计？如何解决缓存过期问题？如何解决内存溢出问题？

## 3、redis和memacached的区别 

## 4、redis常用数据结构和使用场景 

## 5、Zset底层实现？跳表搜索插入删除过程？ 

## 6、redis过期淘汰策略 

## 7、redis持久化机制？都有什么优缺点？持久化的时候还能接受请求吗？ 

## 8、redis事务 

## 9、缓存雪崩和缓存穿透，以及解决方法 

## 10、如何保证缓存和数据库的数据一致性？ 

## 11、redis是单线程还是多线程？为什么那么快？ 

## 12、五种IO模型的区别 

## 13、select、poll、epoll的区别？ 

## 14、redis热key问题？如何发现以及如何解决？ 

## 15、redis数据分布方式？有什么优点？一致性hash呢？ 

## 16、redis主从复制，主从切换，集群 

# **Spring** 

## 1、Spring IOC 

## 2、Spring AOP，动态代理

## 3、Bean生命周期 

## 4、Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的? 

## 5、Spring事务隔离级别和事务传播属性 

## 6、Spring以及Spring MVC常见注解 

## 7、@autowired和@resource的区别，当UserDao存在不止一个bean或没有存在时，会怎样?怎么解决？ 

## 8、mybatis如何防止sql注入？$#的区别是什么？传入表明用哪个？ 

## 9、Spring MVC工作原理 

## 10、SpringBoot自动配置的原理是什么？介绍SpringBootApplication注解. 

## 11、Mybatis和Hibernate的区别 

## 12、spring中的注解原理？例如事务注解，spring如何根据注解实现事务功能的 

## 13、Spring中用到了哪些设计模式？单例、代理、工厂、适配、观察者之类的说一说就行